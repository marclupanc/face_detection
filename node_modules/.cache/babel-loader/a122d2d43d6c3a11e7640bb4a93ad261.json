{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { extractFaces, extractFaceTensors } from '../dom';\nimport { extendWithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { nets } from './nets';\nimport { PredictAllAgeAndGenderWithFaceAlignmentTask, PredictSingleAgeAndGenderWithFaceAlignmentTask } from './PredictAgeAndGenderTask';\nimport { PredictAllFaceExpressionsWithFaceAlignmentTask, PredictSingleFaceExpressionsWithFaceAlignmentTask } from './PredictFaceExpressionsTask';\n\nvar DetectFaceLandmarksTaskBase =\n/** @class */\nfunction (_super) {\n  __extends(DetectFaceLandmarksTaskBase, _super);\n\n  function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {\n    var _this = _super.call(this) || this;\n\n    _this.parentTask = parentTask;\n    _this.input = input;\n    _this.useTinyLandmarkNet = useTinyLandmarkNet;\n    return _this;\n  }\n\n  Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, \"landmarkNet\", {\n    get: function () {\n      return this.useTinyLandmarkNet ? nets.faceLandmark68TinyNet : nets.faceLandmark68Net;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DetectFaceLandmarksTaskBase;\n}(ComposableTask);\n\nexport { DetectFaceLandmarksTaskBase };\n\nvar DetectAllFaceLandmarksTask =\n/** @class */\nfunction (_super) {\n  __extends(DetectAllFaceLandmarksTask, _super);\n\n  function DetectAllFaceLandmarksTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DetectAllFaceLandmarksTask.prototype.run = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var parentResults, detections, faces, _a, faceLandmarksByFace;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResults = _b.sent();\n            detections = parentResults.map(function (res) {\n              return res.detection;\n            });\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, detections)];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, detections)];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            faces = _a;\n            return [4\n            /*yield*/\n            , Promise.all(faces.map(function (face) {\n              return _this.landmarkNet.detectLandmarks(face);\n            }))];\n\n          case 6:\n            faceLandmarksByFace = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , parentResults.map(function (parentResult, i) {\n              return extendWithFaceLandmarks(parentResult, faceLandmarksByFace[i]);\n            })];\n        }\n      });\n    });\n  };\n\n  DetectAllFaceLandmarksTask.prototype.withFaceExpressions = function () {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectAllFaceLandmarksTask.prototype.withAgeAndGender = function () {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\n  };\n\n  return DetectAllFaceLandmarksTask;\n}(DetectFaceLandmarksTaskBase);\n\nexport { DetectAllFaceLandmarksTask };\n\nvar DetectSingleFaceLandmarksTask =\n/** @class */\nfunction (_super) {\n  __extends(DetectSingleFaceLandmarksTask, _super);\n\n  function DetectSingleFaceLandmarksTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DetectSingleFaceLandmarksTask.prototype.run = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var parentResult, detection, faces, _a, landmarks;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResult = _b.sent();\n\n            if (!parentResult) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            detection = parentResult.detection;\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, [detection])];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, [detection])];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            faces = _a;\n            return [4\n            /*yield*/\n            , this.landmarkNet.detectLandmarks(faces[0])];\n\n          case 6:\n            landmarks = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , extendWithFaceLandmarks(parentResult, landmarks)];\n        }\n      });\n    });\n  };\n\n  DetectSingleFaceLandmarksTask.prototype.withFaceExpressions = function () {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectSingleFaceLandmarksTask.prototype.withAgeAndGender = function () {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  };\n\n  DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\n  };\n\n  return DetectSingleFaceLandmarksTask;\n}(DetectFaceLandmarksTaskBase);\n\nexport { DetectSingleFaceLandmarksTask };","map":{"version":3,"mappings":"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","names":["tf","extractFaces","extractFaceTensors","extendWithFaceLandmarks","ComposableTask","ComputeAllFaceDescriptorsTask","ComputeSingleFaceDescriptorTask","nets","PredictAllAgeAndGenderWithFaceAlignmentTask","PredictSingleAgeAndGenderWithFaceAlignmentTask","PredictAllFaceExpressionsWithFaceAlignmentTask","PredictSingleFaceExpressionsWithFaceAlignmentTask","__extends","parentTask","input","useTinyLandmarkNet","_super","_this","Object","DetectFaceLandmarksTaskBase","faceLandmark68TinyNet","faceLandmark68Net","DetectAllFaceLandmarksTask","parentResults","_b","detections","map","detection","Tensor","_a","faces","Promise","all","landmarkNet","detectLandmarks","face","faceLandmarksByFace","forEach","f","dispose","parentResult","i","DetectSingleFaceLandmarksTask","landmarks"],"sources":["../../../src/globalApi/DetectFaceLandmarksTasks.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}